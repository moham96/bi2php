#summary Некоторые детали реализации

= Некоторве детали реализации =

JavaScript позволяет работать с целыми числами не превосходящими +4294967295. Не много, не так ли? Тут нужно прояснить, что летающие числа двойной точности присутствую и могут использоваться но для них операторы сдвига >>, >>>, << и побитовые & и | будут давать неожиданный с точки зрения целых чисел результат. Поэтому длинные целые представлен массивом
BigInt.digits=`[` . . . `]`, из целых чисел до 2`^`16. Впрочем это ограничение немного сужено, так как можно хранить и до 2`^`24, не вызывая потери точности при сложении и умножении, но 16 выбрано так, что удобно хранить по два символа в одном числе как ord(char1) + ord(char2) `*` 2`^`8.

Кстати, поменяв значение "константы" с 16 на 8, или 20 и т.п. (кратное 4) код практически работоспособен, хотя и нуждается в дополнительном тестировании. (Терпение, друзья мои, терпение)

Отрицательные числа тоже работают. Для этого не мудрствую с дополнительным кодом, а тупо присваиваю свойству BigInt.isNeg = true | false.

Особую статью занимают функции ...ByRadix... с виду бесполезные и ненужные. Да, но пока не применяется редукция по Монтгомери. Эта группа функций манипулирует длинными целыми с учетом их конкретной реализации отбрасывая первые/последние N єлементов массива digits, или заполняя его 0 с начала со сдвигом. Єто позволяет избежать дорогостоящие операции деления, взятия модуля, возведения в степени.

Ну и наконец об UTF-8. В UTF-8 кодировании и декодировании нуждается JavaScript, но не PHP, во всяком случае для обычных параметров конфигурации php.ini. Строка JavaScript UTF-8 кодируется и как раз умещается по два символа на один єлеент массива digits. Но это не все. \х0-символ в конце длинного целого строки обрежется. Но не все так плохо. В UTF-8 есть так называемые недопустимые (в кодированном виде) символы. Используем их для замены "нуль"-символа. Другим "недопустимым" символом отметим конец сообщения. Зачем - недоумеваете Вы? Не надо быть гением, чтобы понять что короткое сообщение RSA (например короткий пароль) можно легко прочитать тупо перебрав все возможные варианты и зашифровав их открытым ключом (никакой магии). Поэтому строка падится рандомными символами - отсюда необходимость отметить конец сообщения.

Полученное длинное целое шифруется RSA формируется строка длинных целых разделенных запятой. Тут я не иду не поводу тех библиотек, которые это разделяют пробелом или мы ничего не слышали о URL-кодировании/декодировании.


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages